# invite.modules -- modules and configuration shared by all forwarding INVITE modules
# Copyright (C) 2009  Stephane Alnet
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.

#
# This code is only used by recipes where we forward the INVITE.
# If the INVITE is terminated locally (e.g. with a 302/404 pair)
# then there is no need to use this code in a recipe.
#

#ifnotdef SKIP_UAC_AUTH
branch_route[1]
{
    xlog("L_DBG","DEBUG -- branch_route(1) Processing $rm $ru");

    xlog("L_DBG","DEBUG -- branch_route(1) Routing tgw $(avp(tgw))");

    # Modify the RURI to use the new target.
    $ru = "sip:" + $rU + "@" + $(avp(tgw));

    # Per-provider authentication
    avp_db_load("$(avp(tgw))","$(avp(uac_realm))"); # Must match the realm sent by the remote end
    avp_db_load("$(avp(tgw))","$(avp(uac_user))");
    avp_db_load("$(avp(tgw))","$(avp(uac_pass))");
}
#endifnotdef SKIP_UAC_AUTH

onreply_route[1]
{
  xlog("L_DBG","DEBUG -- onreply_route(1) Received from $si with flags $mf: $mb");
  xlog("L_DBG","DEBUG -- onreply_route(1) $rs $rr");

  # In-progress flag
  if( t_check_status("[12][0-9][0-9]") )
  {
      setbflag(18);
  }

  route(media-proxy-reply-handler); # MP on-reply
  route(onreply-nat); # NAT on-reply
}

# -----------------------------------------------------------------
# Failure route
# -----------------------------------------------------------------

failure_route[1]
{
    xlog("L_DBG","DEBUG -- failure_route(1): $rm $ru");

    if(!is_method("INVITE"))
    {
      return;
    }

    # For fax negotiation 488 might be a normal outcome.
    if(!t_check_status("488"))
    {
      route(stop-media-proxy); # End media session
    }

    if(t_was_cancelled() || t_check_status("504"))
    {
        xlog("L_DBG","DEBUG -- failure_route[1]: conversation was canceled.");
    }
    else
    {
        #ifnotdef SKIP_UAC_AUTH
        if($avp(uac_realm))
        {
          # Check whether we were supposed to authenticate (uac_auth)
          if( t_check_status("40[17]") )
          {
              # Already attempted.
              # Note: this breaks if we failover (e.g. SRV or multiple DNS As)
              if(isbflagset(11))
              {
                  xlog("L_DBG","DEBUG -- failure_route(1): uac_auth already attempted.");
                  t_reply("503","Authentication failed");
                  exit;
              }

              xlog("L_DBG","DEBUG -- failure_route(1): Attempting uac_auth.");
              if(uac_auth())
              {
                  setbflag(11);
                  t_on_failure("1");
                  route(initial-forwarder);
                  exit;
              }
              else
              {
                  xlog("L_ERR","ERROR -- failure_route(1): uac_auth() failed on $rm $ru");
                  exit;
              }
          }
        }

        resetbflag(11);
        #endifnotdef SKIP_UAC_AUTH

        # Handle redirects
        if( t_check_status("302") )
        {
            get_redirects("6:2","Redirected"); # max_total:max_branch, reason
            append_branch();
            route(forwarder);
            exit;
        }

        # Process failure cases
        if (next_branches()) {
            route(forwarder);
            exit;
        }
        #ifdef USE_DROUTING
        if (next_routing()) {
          route(forwarder);
          exit;
        }
        #endifdef USE_DROUTING

        # Line-side processing
        #ifnotdef SKIP_LINESIDE
        if( $(avp(dst_subs)) ) {
            xlog("L_DBG","DEBUG -- failure_route(1): line-side failure route");

            # On 486 Busy Here use CFB
            # Note: For 480, using CFNR may be more appropriate.
            if( t_check_status("48[067]") )
            {
                xlog("L_DBG","DEBUG -- failure_route(1): Attempting CFB");

                # Locate the CFB AVP, and use it if we haven't already
                if( $(avp(cfb)) && !isbflagset(9) )
                {
                    xlog("L_DBG","DEBUG -- failure_route(1): Applying CFB");
                    setbflag(9);

                    # Replace the Request-URI with the CFB target
                    $ru = $(avp(cfb));
                    # Append a new branch based on the CFB and route it out.
                    # XXX I don't think this is necessary.
                    append_branch();
                    route(initial-forwarder);
                    exit;
                }
                # Fallthrough
            }

            # See if we need to CFDA
            # Locate the CFDA AVP
            xlog("L_DBG","DEBUG -- Attempting CFDA");
            if( $(avp(cfda)) && !isbflagset(10) )
            {
                xlog("L_DBG","DEBUG -- failure_route(1): Applying CFDA");
                setbflag(10);

                # Replace the Request-URI with the CFDA target
                $ru = $(avp(cfda));
                # Append a new branch based on the CFDA and route it out.
                # XXX I don't think this is necessary.
                append_branch();
                route(initial-forwarder);
                exit;
            }
            # Fallthrough: no alternate found, fail the call.
        }
        #endifnotdef SKIP_LINESIDE

        #ifnotdef SKIP_GWADV
        if($(avp(gwadv))) {
        # Trunk-side processing
            # Don't failover on busy, loop detected, incomplete address, or not found
            # Note: 480 used to be here but since it is used as catch-all by FS it is better to progress on it.
            if( t_check_status("48[67241]|40[34]|60[0-9]") )
            {
                xlog("L_DBG","DEBUG -- failure_route(1): trunk: no progress on busy, loop, incomplete, forbidden, not found");
                return;
            }
            # Ring no Answer
            if( isbflagset(18) && t_check_status("408") )
            {
                xlog("L_DBG","DEBUG -- failure_route(1): trunk: no answer");
                t_reply("486","No Answer");
                return;
            }

            # Attempt to find a failover endpoint
            if( avp_db_load( "$(avp(gwadv))", "$(avp(gwadv))" ) )
            {
                xlog("L_DBG","DEBUG -- failure_route(1): route advance to $(avp(gwadv))");
                route(trunk-side-invite);
                # XXX I don't think this is necessary.
                append_branch();
                route(initial-forwarder);
                exit;
            }
            else
            {
                # This is a normal scenario for the last entry in a route-set
                xlog("L_DBG","DEBUG -- failure_route(1): no route advance for $(avp(gwadv))");

                # Try aliases as a fallback.
                if(alias_db_lookup("aliases"))
                {
                    xlog("L_DBG","DEBUG -- failure_route(1): using alias $ru");
                    # XXX I don't think this is necessary.
                    append_branch();
                    route(initial-forwarder);
                    exit;
                }
                else
                {
                    xlog("L_DBG","DEBUG -- failure_route(1): no alias either, terminating the call.");
                }
            }
            # Fallthrough: no alternate found
        }

        #endifnotdef SKIP_GWADV
    }
}
