#
# Automatically generated for recipe inbound-proxy
#

## ---  Start ./generic.modules  --- ##

## ------- Modules ---------- ##

# -- FIFO --
loadmodule "mi_fifo.so"
modparam("mi_fifo","fifo_name", "/tmp/opensips_fifo")

# -- MySQL --
loadmodule "db_mysql.so"

# -- Flat store --
loadmodule "db_flatstore.so"
# Flush flatstore after each write (may have to be changed to 0)
modparam("db_flatstore", "flush", 1)

# -- Common --
loadmodule "xlog.so"
loadmodule "sl.so"

loadmodule "tm.so"
# Timeout for Final reply for request or ACK for negative INVITE reply
# This is the time we wait to failover if a carrier is dead, basically.
# 6 seconds is one ring cycle.
modparam("tm", "fr_timer", 6)
# Timeout for Final reply for INVITE after provisional msg (1xx or 2xx)
# This is the time we wait for ringing before trying the next route.
modparam("tm", "fr_inv_timer", ${INV_TIMER})
# default is 120
# Same, as an AVP
modparam("tm", "fr_inv_timer_avp", "$(avp(inv_timer))")
# noisy_ctimer: Recommended by Gafachi, probably makes sense in this application
# modparam("tm", "noisy_ctimer", 1)

# For better interaction with broken (pre-3261) devices
modparam("tm", "ruri_matching", 0)
modparam("tm", "via1_matching", 0)


loadmodule "rr.so"
# Workaround for older SIP clients
modparam("rr", "enable_full_lr", 1)


loadmodule "maxfwd.so"
loadmodule "uri.so"
loadmodule "textops.so"

# -- usrloc --
loadmodule "usrloc.so"
# Use usrloc-cl (DB-based)
modparam("usrloc", "db_url",          "${DB_URL}")
modparam("usrloc", "db_mode",         3)
modparam("usrloc", "timer_interval",  60)
modparam("usrloc", "desc_time_order", 1)
modparam("usrloc", "nat_bflag",       6)
modparam("usrloc", "use_domain",      1)

# -- uri_db ---
loadmodule "uri_db.so"
modparam("uri_db", "db_url",          "${DB_URL}")
modparam("uri_db", "use_domain",      1)
modparam("uri_db", "use_uri_table",   0) # use the "subscriber" table

# -- domain --
loadmodule "domain.so"
modparam("domain", "domain_table",    "domain")

# -- avpops --
loadmodule "avpops.so"
modparam("avpops", "avp_url",         "${DB_URL}")
modparam("avpops", "avp_table",       "avpops")
modparam("avpops", "use_domain",      1)

# -- permissions (allow_trusted) --
loadmodule "permissions.so"
modparam("permissions", "db_url",     "${DB_URL}")
modparam("permissions", "peer_tag_avp", "$avp(peer_tag_avp)")
# How the permissions module should use SQL for its data
# 0 is "disable cache"
modparam("permissions", "db_mode", 0)
modparam("permissions", "trusted_table", "trusted")


## ---  End ./generic.modules  --- ##


## ---  Start ./accounting.modules  --- ##

loadmodule "acc.so"

modparam("acc", "log_extra", "${CDR_EXTRA}")
modparam("acc", "db_extra", "${CDR_EXTRA}")
#IFACCTRADIUS   modparam("acc", "radius_config", "${RADIUS_CONFIG}")
# These attributes need to be defined in a "dictionary" file first.
#IFACCTRADIUS   modparam("acc", "radius_extra", "${RADIUS_EXTRA}")

modparam("acc", "log_flag",1) # Normally not used
modparam("acc", "log_level",1)

# Accounting in flat text file
modparam("acc", "report_cancels", 1)
modparam("acc", "early_media", 1)
modparam("acc", "report_ack", 1)
modparam("acc", "failed_transaction_flag", 12)
modparam("acc", "db_flag",2)
modparam("acc", "db_missed_flag", 3)
modparam("acc", "db_table_acc", "acc")
modparam("acc", "db_table_missed_calls", "missed_calls")
modparam("acc", "db_url", "flatstore:/var/log/opensips")

# Accounting via RADIUS
#IFACCTRADIUS   modparam("acc", "radius_flag", 4)
#IFACCTRADIUS   modparam("acc", "radius_missed_flag", 5)

#IFACCTRADIUS       modparam("uac_redirect","acc_function","acc_rad_request")
#IFACCTFLATSTORE    modparam("uac_redirect","acc_function","acc_db_request")


## ---  End ./accounting.modules  --- ##


## ---  Start ./generic.cfg  --- ##

# ROUTING

route
{
  route(3);

  xlog("L_DBG","DEBUG -- route() $rm From: $fu To: $tu RURI: $ru");

  if(loose_route())
  {
    route(5);
    exit;
  }
  else
  {
    if(is_uri_host_local())
    {
      route(7);
      exit;
    }
    else
    {
      route(6);
      exit;
    }
  }
}
## ---  End ./generic.cfg  --- ##


## ---  Start ./forwarder.cfg  --- ##

# -----------------------------------------------------------------
# Default Message Forwarder (anything except ACK/PRACK/CANCEL)
# -----------------------------------------------------------------

route[1] {
    xlog("L_DBG","DEBUG -- route(1) Processing $rm $ru");

    if($(avp(dest_domain)))
    {
        xlog("L_DBG","DEBUG -- route(1) Using destination $(avp(dest_domain))");
        $rd = $(avp(dest_domain));
    }

    xlog("L_DBG","DEBUG -- route(1) t_relay $rm $ru");

    if (!t_relay("0x01")) # Prevent dup 100
    {
        # t_relay failed, check if we need to stop mediaproxy
        if (is_method("INVITE")) {
            ; # End media session
        };
        sl_send_reply("500","Transmission failure");
    };
    exit;
}

# -----------------------------------------------------------------
# Forward ACK, PRACK, and CANCEL
# -----------------------------------------------------------------

route[2]
{
    xlog("L_DBG","DEBUG -- route(2) ACK/PRACK/CANCEL Processing $rm $ru");

    if(!t_check_trans())
    {
        xlog("L_DBG", "DEBUG -- route(2) Dropping mis-routed $rm (481)");
        # Can't send a reply to an ACK
        if(!is_method("ACK"))
        {
            sl_send_reply("481", "Call/Transaction Does Not Exist");
        }
        exit;
    }

    xlog("L_DBG", "DEBUG -- route(2) t_relay $rm $ru");
    if(!t_relay())
    {
        # t_relay failed, check if we need to stop mediaproxy
        if (is_method("ACK")) {
            ; # End media session
        };
        sl_send_reply("500","Transmission failure");
    };
    exit;
}


## ---  End ./forwarder.cfg  --- ##


## ---  Start ./accounting.cfg  --- ##


route[9]
{
    # Enable accounting of calls in syslog
    # setflag(1);
    # Enable accounting of calls in the flatstore database
    setflag(2);
    # Enable accounting of missed calls in the flatstore database
    setflag(3);

#IFACCTRADIUS   # Enable accounting of calls in Radius
#IFACCTRADIUS   setflag(4);
#IFACCTRADIUS   # Enable accounting of missed calls in Radius
#IFACCTRADIUS   setflag(5);
}

## ---  End ./accounting.cfg  --- ##


## ---  Start ./invite-inbound-proxy.cfg  --- ##

# -----------------------------------------------------------------
# INVITE Message Handler
# -----------------------------------------------------------------

route[4]
{
    xlog("L_DBG","DEBUG -- route(4) $ru -- INVITE Message Handler");

    sl_send_reply("100", "Trying");

    t_on_failure("1");
    t_on_reply("1");

    xlog("L_DBG","DEBUG -- route(4): From ip: $si - From URI: $fu");

    # Need to be able to route based on:
    # - calling number + called number
    # - called number
    # - calling number
    if(lookup("aliases"))
    {
      ;   # Start MP if needed
      route(1);   # Forward
      exit;
    }
    else
    {
      # Invalid destination
      sl_send_reply("404", "User Not Found");
      exit;
    }
}


onreply_route[1]
{
  xlog("L_DBG","DEBUG -- onreply_route(forwarder) Received from $si with flags $mf: $mb");
  xlog("L_DBG","DEBUG -- onreply_route(forwarder) $rs $rr");

  # In-progress flag
  if( t_check_status("[12][0-9][0-9]") )
  {
      setbflag(18);
  }

  ; # MP on-reply
  ; # NAT on-reply
}

# -----------------------------------------------------------------
# Failure route
# -----------------------------------------------------------------

failure_route[1]
{
    xlog("L_DBG","DEBUG -- failure_route(forwarder): $rm $ru");

    if(!is_method("INVITE"))
    {
      return;
    }

    # For fax negotiation 488 might be a normal outcome.
    if(!t_check_status("488"))
    {
      ; # End media session
    }

    if(t_was_cancelled() || t_check_status("504"))
    {
        xlog("L_DBG","DEBUG -- failure_route[1]: conversation was canceled.");
    }
    else
    {
        # Handle redirects
        if( t_check_status("302") )
        {
            get_redirects("6:2","Redirected"); # max_total:max_branch, reason
            route(1);
            exit;
        }

        # Process failure cases
        if (next_branches()) {
            route(1);
            exit;
        }

            # Fallthrough: no alternate found, fail the call.
        }
    }
}

## ---  End ./invite-inbound-proxy.cfg  --- ##


## ---  Start ./loose-route.cfg  --- ##

# -----------------------------------------------------------------
# Loose Route Section
# -----------------------------------------------------------------

route[5]
{
    xlog("L_DBG","DEBUG -- route(5): loose_route $rm From: $fu To: $tu RURI: $ru");

    if((is_method("INVITE") || is_method("REFER")) && !has_totag()) {
        sl_send_reply("403", "Forbidden");
        exit;
    };

    sl_send_reply("100", "Trying");

    route(8); # Is this needed?

    ;
    ;
    route(9);

    if(is_method("BYE") || is_method("CANCEL"))
    {
      ; # End media session
    }

    if(is_method("ACK") || is_method("CANCEL") || is_method("PRACK"))
    {
        route(2); # Route ACK/PRACK/CANCEL
    }
    else
    {
        route(1);
    }
    return;
}

## ---  End ./loose-route.cfg  --- ##


## ---  Start ./non-loose-route.cfg  --- ##

# -----------------------------------------------------------------
# Out-of-Dialog messages
# -----------------------------------------------------------------

# With local URI

# This code is for a router with local registrar

route[7]
{
    xlog("L_DBG","DEBUG -- route(7) Out-of-dialog: $rm $ru (Call-ID $ci)");

    sl_send_reply("100", "Trying");

    route(8);

    if(is_method("REGISTER"))
    {
      ;   # REGISTER message handler
      exit;
    }

    ;

    if(is_method("BYE") || is_method("CANCEL"))
    {
      ; # End media session
    }

    if(is_method("SUBSCRIBE"))
    {
      route(1);
      exit;
    }

    if(is_method("NOTIFY"))
    {
      lookup("location");
      route(1);
      exit;
    }

    route(9);

    if(is_method("INVITE"))
    {
      setflag(19); # dlg_flag
      create_dialog();
      ;  # NAT
      route(4);   # INVITE message handler
      exit;
    }

    if(is_method("ACK"))
    {
      ;
      route(2);   # Route ACK & CANCEL
      exit;
    }

    if(is_method("CANCEL")||is_method("PRACK"))
    {
      ;  # NAT traversal for BYE and CANCEL
      route(2);   # Route ACK/PRACK/CANCEL
      exit;
    }

    if(is_method("BYE"))
    {
      ;  # NAT traversal for BYE and CANCEL
      route(1);   # Route
      exit;
    }

    xlog("L_DBG","DBG -- route(7) Unsupported method $rm");
    sl_send_reply("501","Not implemented");
    exit;
}

# With non-local URI

route[6]
{
    xlog("L_DBG","DEBUG -- route(6) Non-local RURI $ru");

    # XXX is this code ever used??
    # XXX Shouldn't we authenticate or something?

    ## if(is_from_local()) {
    ##    ;   # Start MP if needed
    ##    route(1);
    ##    exit;
    ## }
    ## else
    ## {
        xlog("L_DBG","DEBUG -- route() Relaying forbidden");
        sl_send_reply("403", "Relaying Forbidden");
        exit;
    ## };
};

## ---  End ./non-loose-route.cfg  --- ##


## ---  Start ./toolbox.cfg  --- ##

route[3]
{
  # Silently drop "OPTIONS" (used by phones to ping the server).
  if(is_method("OPTIONS"))
  {
    sl_send_reply("405", "Method Not Allowed");
    exit;
  }

  # Group 1 is actually a list of black-listed IP addresses or blocks.
  if(allow_source_address("1"))
  {
    sl_send_reply("100", "Trying");
    sl_send_reply("503", "Service Unavailable");
    exit;
  }

  xlog("L_DBG","DEBUG -- Received from $si with flags $mf: $mb");

  # -----------------------------------------------------------------
  # Sanity Check Section
  # -----------------------------------------------------------------
  if (!mf_process_maxfwd_header("${MAX_HOPS}"))
  {
    xlog("L_DBG","DEBUG -- Too Many Hops: $rm From: $fu To: $tu");
    if( !is_method("ACK") )
    {
      sl_send_reply("483", "Too Many Hops");
    };
    exit;
  };

  if (msg:len > max_len)
  {
    xlog("L_DBG","INFO -- Message Overflow: $rm From: $fu To: $tu");
    if( !is_method("ACK") ) {
      sl_send_reply("513", "Message Overflow");
    };
    exit;
  };
}


## ---  End ./toolbox.cfg  --- ##


## ---  Start ./register-ignore.cfg  --- ##

# -----------------------------------------------------------------
# REGISTER Message Handler: Router for a remote registrar
# -----------------------------------------------------------------

# Router for a remote registrar

route[8]
{
  # No message are terminated locally.
  record_route();
}

## ---  End ./register-ignore.cfg  --- ##


# route(1) => route(forwarder)
# route(2) => route(forwarder-progress)
# route(3) => route(initialize)
# route(4) => route(invite-handler)
# route(5) => route(loose-route-handler)
# route(6) => route(non-local-uri-handler)
# route(7) => route(non-loose-route-handler)
# route(8) => route(record-route)
# route(9) => route(start-accounting)
