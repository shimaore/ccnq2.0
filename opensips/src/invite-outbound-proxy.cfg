route[invite-handler]
{
    xlog("L_DBG","DEBUG -- route(invite-handler) $ru -- INVITE Message Handler (Outbound Proxy)");

    sl_send_reply("100", "Trying");

    t_on_failure("1");
    t_on_reply("1");

    xlog("L_DBG","DEBUG -- route(invite-handler): From ip: $si - From URI: $fu");

    # Need to be able to route based on:
    # - calling number + called number
    # - called number
    # - calling number
    # For the outbound-proxy, needs to be able to do LCR.
    # See http://www.opensips.org/html/docs/modules/1.5.x/drouting.html

    route(try-trunk-side);

    if(lookup("aliases"))
    {
      route(update-media-proxy);   # Start MP if needed
      route(forwarder);   # Forward
      exit;
    }
    else
    {
      # Invalid destination
      sl_send_reply("404", "User Not Found");
      exit;
    }
}

# Route $(avp(gwadv)) to its final destination
route[trunk-side-invite]
{
    xlog("L_DBG","DEBUG -- route(trunk-side-invite) Routing gwadv $(avp(gwadv))");

    # If we have a node-id, first try to locate a route specific to this node.
    # The AVP key is the route name followed by '/' then the node_id.
#IFNODE_ID $var(local_route) = $(avp(gwadv)) + '/${NODE_ID}';
#IFNODE_ID if( ! avp_db_load("$var(local_route)","$(avp(tgw))") )
#IFNODE_ID {

    # Find the generic target ip:port for this route
    if( ! avp_db_load("$(avp(gwadv))","$(avp(tgw))") )
    {
        return(-1);
    }

#IFNODE_ID }

    xlog("L_DBG","DEBUG -- route(trunk-side-invite) Location $(avp(tgw))");

    t_on_branch("1");
    return(1);
}

branch_route[1]
{
    xlog("L_DBG","DEBUG -- branch_route(forwarder) Processing $rm $ru");

    xlog("L_DBG","DEBUG -- branch_route(forwarder) Routing tgw $(avp(tgw))");

    # Modify the RURI to use the new target.
    $ru = "sip:" + $rU + "@" + $(avp(tgw));

    # Per-provider authentication
    avp_db_load("$(avp(tgw))","$(avp(uac_realm))"); # Must match the realm sent by the remote end
    avp_db_load("$(avp(tgw))","$(avp(uac_user))");
    avp_db_load("$(avp(tgw))","$(avp(uac_pass))");
}


onreply_route[1]
{
  xlog("L_DBG","DEBUG -- onreply_route(forwarder) Received from $si with flags $mf: $mb");
  xlog("L_DBG","DEBUG -- onreply_route(forwarder) $rs $rr");

  # In-progress flag
  if( t_check_status("[12][0-9][0-9]") )
  {
      setbflag(18);
  }

  route(media-proxy-reply-handler); # MP on-reply
  route(onreply-nat); # NAT on-reply
}

# -----------------------------------------------------------------
# Failure route
# -----------------------------------------------------------------

failure_route[1]
{
    xlog("L_DBG","DEBUG -- failure_route(forwarder): $rm $ru");

    if(!is_method("INVITE"))
    {
      return;
    }

    # For fax negotiation 488 might be a normal outcome.
    if(!t_check_status("488"))
    {
      route(stop-media-proxy); # End media session
    }

    if(t_was_cancelled() || t_check_status("504"))
    {
        xlog("L_DBG","DEBUG -- failure_route[1]: conversation was canceled.");
    }
    else
    {
        # Handle redirects
        if( t_check_status("302") )
        {
            get_redirects("6:2","Redirected"); # max_total:max_branch, reason
            route(forwarder);
            exit;
        }

        # Process failure cases
        if (next_branches()) {
            route(forwarder);
            exit;
        }

        if($(avp(gwadv))) {
        # Trunk-side processing
            # Don't failover on busy, loop detected, incomplete address, or not found
            # Note: 480 used to be here but since it is used as catch-all by FS it is better to progress on it.
            if( t_check_status("48[67241]|40[34]|60[0-9]") )
            {
                xlog("L_DBG","DEBUG -- failure_route(forwarder): trunk: no progress on busy, loop, incomplete, forbidden, not found");
                return;
            }
            # Ring no Answer
            if( isbflagset(18) && t_check_status("408") )
            {
                xlog("L_DBG","DEBUG -- failure_route(forwarder): trunk: no answer");
                t_reply("486","No Answer");
                return;
            }

            # Attempt to find a failover endpoint
            if( avp_db_load( "$(avp(gwadv))", "$(avp(gwadv))" ) )
            {
                xlog("L_DBG","DEBUG -- failure_route(forwarder): route advance to $(avp(gwadv))");
                route(trunk-side-invite);
                append_branch();
                route(forwarder);
                exit;
            }
            else
            {
                # This is a normal scenario for the last entry in a route-set
                xlog("L_DBG","DEBUG -- failure_route(forwarder): no route advance for $(avp(gwadv))");

                # Try aliases as a fallback.
                if(lookup("aliases"))
                {
                    xlog("L_DBG","DEBUG -- failure_route(forwarder): using alias $ru");
                    append_branch();
                    route(forwarder);
                    exit;
                }
                else
                {
                    xlog("L_DBG","DEBUG -- failure_route(forwarder): no alias either, terminating the call.");
                }
            }
            # Fallthrough: no alternate found
        }
    }
}
