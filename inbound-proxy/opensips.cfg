# openser.cfg
# Copyright (C) 2006-2009  Stephane Alnet
#
# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation; either version 3
# of the License, or (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#

#
# For more information visit http://carrierclass.net/
#

#
# Inbound Proxy template
# For OpenSIPS 1.5
#

# This is a very simple configuration template.
# The source IP address is checked to be a known IP, although in practice
# this is simpler done by filtering IP and port with a host-based firewall.
# Routing is then done using a lookup() command.
# No NAT or media support.

# STARTUP

# The following variables MUST be substituted before this configuration file is used:
#   ${PROXY_IP}     The IP address of the local proxy
#   ${PROXY_PORT}   The UDP port of the local proxy
#   ${DB_URL}       The URL to be used for the database storing data for this proxy
#   ${AVP_ALIASES}
#   ${RADIUS_CONFIG}    Location of the Radius library config file (e.g. /usr/local/etc/radiusclient/radiusclient.conf )

# What IP address to listen onto; no statement == listen on all interfaces
listen=${PROXY_IP}
port=${PROXY_PORT}

# Flags used:
# flag 1 = log (acc.so)
# flag 2 = flatstore billing (acc.so)
# flag 3 = flatstore missed calls (acc.so)
# flag 4 = radius billing (acc.so)
# flag 5 = radius logs missed calls too (acc.so)
# flag 6 = force MediaProxy
# flag 7 = msg sender (caller) is NATed
# flag 8 = set if mediaproxy already invoked (on this leg) [bflag]
# flag 9 = set if CFB already attempted [bflag]
# flag 10 = set if CFDA already attempted [bflag]
# flag 11 = set if uac_auth done [bflag]
# flag 12 = failed transaction flag
# flag 16 = call is been recorded
# bflag 18 = call in progress
# flag 19 = dialog flag (dialog.so)

# Debug level (syslog)
debug=${DEBUG}
# Fork is yes for normal use
fork=yes
# Do not log to STDERR
log_stderror=no

# Children=4 or higher (in production)
children=4

# Suppress any warnings about our IP not being in the DNS server
dns=no
rev_dns=no
# This is now the default in 1.3.
disable_dns_blacklist=yes

avp_aliases="${AVP_ALIASES}"

# Module path
mpath="${MPATH}"

# --- mi_fifo
loadmodule "mi_fifo.so"
modparam("mi_fifo","fifo_name", "/tmp/opensips_fifo")

# --- db_mysql
loadmodule "db_mysql.so"

# --- xlog
loadmodule "xlog.so"

# --- sl
loadmodule "sl.so"

# --- tm
loadmodule "tm.so"
# Timeout for Final reply for request or ACK for negative INVITE reply
# This is the time we wait to failover if a carrier is dead, basically.
# 6 seconds is one ring cycle.
modparam("tm", "fr_timer", 6)
# Timeout for Final reply for INVITE after provisional msg (1xx or 2xx)
# This is the time we wait for ringing before trying the next route.
modparam("tm", "fr_inv_timer", ${INV_TIMER})
# default is 120
# Same, as an AVP
modparam("tm", "fr_inv_timer_avp", "$(avp(inv_timer))")
# noisy_ctimer: Recommended by Gafachi, probably makes sense in this application
# modparam("tm", "noisy_ctimer", 1)

# For better interaction with broken (pre-3261) devices
modparam("tm", "ruri_matching", 0)
modparam("tm", "via1_matching", 0)

# --- rr
loadmodule "rr.so"
# Workaround for older SIP clients
modparam("rr", "enable_full_lr", 1)

# --- maxfwd
loadmodule "maxfwd.so"

# --- uri
loadmodule "uri.so"

# --- domain
loadmodule "domain.so"
loadmodule "textops.so"
loadmodule "avpops.so"
modparam("avpops", "avp_url", "${DB_URL}")
modparam("avpops", "avp_table", "avpops")
modparam("avpops", "use_domain", 1)

loadmodule "acc.so"
modparam("acc", "log_extra", "${CDR_EXTRA}")
modparam("acc", "db_extra", "${CDR_EXTRA}")
#IFACCTRADIUS   modparam("acc", "radius_config", "${RADIUS_CONFIG}")
# These attributes need to be defined in a "dictionary" file first.
#IFACCTRADIUS   modparam("acc", "radius_extra", "${RADIUS_EXTRA}")

modparam("acc", "log_flag",1) # Normally not used
modparam("acc", "log_level",1)

# Accounting in flat text file
modparam("acc", "report_cancels", 1)
modparam("acc", "early_media", 1)
modparam("acc", "report_ack", 1)
modparam("acc", "failed_transaction_flag", 12)
modparam("acc", "db_flag",2)
modparam("acc", "db_missed_flag", 3)
modparam("acc", "db_table_acc", "acc")
modparam("acc", "db_table_missed_calls", "missed_calls")
modparam("acc", "db_url", "flatstore:/var/log/opensips")

# Accounting via RADIUS
#IFACCTRADIUS   modparam("acc", "radius_flag", 4)
#IFACCTRADIUS   modparam("acc", "radius_missed_flag", 5)


loadmodule "db_flatstore.so"
# Flush flatstore after each write (may have to be changed to 0)
modparam("db_flatstore", "flush", 1)

loadmodule "uac_redirect.so"
#IFACCTRADIUS       modparam("uac_redirect","acc_function","acc_rad_request")
#IFACCTFLATSTORE    modparam("uac_redirect","acc_function","acc_db_request")

# loadmodule "dialog.so"
# modparam("dialog", "dlg_flag", 19)

# ROUTING

route
{
    # Group 1 is actually a list of black-listed IP addresses or blocks.
    if(allow_source_address("1"))
    {
        sl_send_reply("100", "Trying");
        sl_send_reply("503", "Service Unavailable");
        exit;
    }

    xlog("L_DBG","DEBUG -- Received from $si with flags $mf: $mb");

    # -----------------------------------------------------------------
    # Sanity Check Section
    # -----------------------------------------------------------------
    if (!mf_process_maxfwd_header("${MAX_HOPS}"))
    {
        xlog("L_DBG","DEBUG -- Too Many Hops: $rm From: $fu To: $tu");
        if( !is_method("ACK") )
        {
            sl_send_reply("483", "Too Many Hops");
        };
        exit;
    };

    if (msg:len > max_len)
    {
        xlog("L_DBG","INFO -- Message Overflow: $rm From: $fu To: $tu");
        if( !is_method("ACK") ) {
            sl_send_reply("513", "Message Overflow");
        };
        exit;
    };

    # -----------------------------------------------------------------
    # Record Route Section
    # -----------------------------------------------------------------

    # REGISTER messages are processed locally.
    # For all other messages, make sure we stay in the path.
    if ( !is_method("REGISTER") )
    {
        record_route();
    };

    # -----------------------------------------------------------------
    # Loose Route Section
    # -----------------------------------------------------------------
    if (loose_route())
    {
        route(5);
        exit;
    };

    # -----------------------------------------------------------------
    # Call Type Processing Section
    # -----------------------------------------------------------------
    xlog("L_DBG","DEBUG -- route() $rm From: $fu To: $tu RURI: $ru");

    if (!is_uri_host_local())
    {
        xlog("L_DBG","DEBUG -- route() Non-local RURI $ru");

        xlog("L_DBG","DEBUG -- route() Relaying forbidden");
        sl_send_reply("403", "Relaying Forbidden");
        exit;
    };

    # ----------------------------------------------------------------
    # Here starts the section on Out-of-dialog messages
    # (either start a new dialog, or relaying/proxying a message)
    # ----------------------------------------------------------------
    route(6);
    exit;
}


# -----------------------------------------------------------------
# Out-of-Dialog Section
# -----------------------------------------------------------------

route[7]
{
  xlog("L_DBG","DEBUG -- route(7) Set accounting");

  # Enable accounting of calls in syslog
  # setflag(1);
  # Enable accounting of calls in the flatstore database
  setflag(2);
  # Enable accounting of missed calls in the flatstore database
  setflag(3);

#IFACCTRADIUS   # Enable accounting of calls in Radius
#IFACCTRADIUS   setflag(4);
#IFACCTRADIUS   # Enable accounting of missed calls in Radius
#IFACCTRADIUS   setflag(5);

  
}

route[6]
{
  xlog("L_DBG","DEBUG -- route(6) Out-of-dialog: $rm $ru (Call-ID $ci)");

  if(is_method("INVITE"))
  {
    route(7);
    route(3);   # INVITE message handler
    exit;
  }
  if(is_method("ACK"))
  {
    route(7);
    route(8);   # Route ACK & CANCEL
    exit;
  }
  if(is_method("CANCEL")||is_method("PRACK"))
  {
    route(7);
    route(8);   # Route ACK/PRACK/CANCEL
    exit;
  }
  if(is_method("BYE"))
  {
    route(7);
    route(1);   # Route
    exit;
  }

  xlog("L_DBG","DBG -- route(6) Unsupported method $rm");
  sl_send_reply("501","Not implemented");
  exit;
}

# -----------------------------------------------------------------
# Default Message Forwarder (anything except ACK/PRACK/CANCEL)
# -----------------------------------------------------------------

route[1] {
    xlog("L_DBG","DEBUG -- route(1) Processing $rm $ru");

    if($(avp(dest_domain)))
    {
        xlog("L_DBG","DEBUG -- route(1) Using destination $(avp(dest_domain))");
        $rd = $(avp(dest_domain));
    }

    t_on_failure("1");

    xlog("L_DBG","DEBUG -- route(1) t_relay $rm $ru");

    if (!t_relay("0x01")) # Prevent dup 100
    {
        sl_send_reply("500","Transmission failure");
    };
    exit;
}

# -----------------------------------------------------------------
# Forward ACK, PRACK, and CANCEL
# -----------------------------------------------------------------

route[8]
{
    xlog("L_DBG","DEBUG -- route(8) ACK/PRACK/CANCEL Processing $rm $ru");

    t_on_failure("1");

    if(!t_check_trans())
    {
        xlog("L_DBG", "DEBUG -- route(8) Dropping mis-routed $rm (481)");
        # Can't send a reply to an ACK
        if(!is_method("ACK"))
        {
            sl_send_reply("481", "Call/Transaction Does Not Exist");
        }
        exit;
    }

    xlog("L_DBG", "DEBUG -- route(8) t_relay $rm $ru");
    if(!t_relay())
    {
        sl_send_reply("500","Transmission failure");
    };
    exit;
}

# -----------------------------------------------------------------
# Failure route
# -----------------------------------------------------------------

failure_route[1]
{
    xlog("L_DBG","DEBUG -- failure_route(1): $rm $ru");

    # Enable accounting of calls in syslog
    # setflag(1);
    # Enable accounting of calls in the flatstore database
    setflag(2);
    # Enable accounting of missed calls in the flatstore database
    setflag(3);

#IFACCTRADIUS   # Enable accounting of calls in Radius
#IFACCTRADIUS   setflag(4);
#IFACCTRADIUS   # Enable accounting of missed calls in Radius
#IFACCTRADIUS   setflag(5);

    # Failed transaction flag
    setflag(12);

    if(!is_method("INVITE"))
    {
      return;
    }

    if(!t_was_cancelled() && !t_check_status("504"))
    {
        # Handle redirects
        if( t_check_status("302") )
        {
            get_redirects("6:2","Redirected"); # max_total:max_branch, reason
            route(1);
            exit;
        }

        # Process failure cases
        if (next_branches()) {
            route(1);
            exit;
        }

        # Is the call going to a trunk or to a line?
        if( $(avp(dst_subs)) )
        # Line-side processing
        {
            # Call is going to a phone, process CFB, CFDA, etc.
            xlog("L_DBG","DEBUG -- failure_route(1): line-side failure route");

            # On 486 Busy Here use CFB
            # Note: For 480, using CFNR may be more appropriate.
            if( t_check_status("48[067]") )
            {
                xlog("L_DBG","DEBUG -- failure_route(1): Attempting CFB");

                # Locate the CFB AVP
                if( $(avp(cfb)) && !isbflagset(9) )
                {
                    xlog("L_DBG","DEBUG -- failure_route(1): Applying CFB");
                    setbflag(9);

                    # Replace the Request-URI with the CFB target
                    $ru = $(avp(cfb));
                    # Append a new branch based on the CFB and route it out.
                    append_branch();
                    route(1);
                    exit;
                }
                # Fallthrough
            }

            # See if we need to CFDA
            # Locate the CFDA AVP
            xlog("L_DBG","DEBUG -- Attempting CFDA");
            if( $(avp(cfda)) && !isbflagset(10) )
            {
                xlog("L_DBG","DEBUG -- failure_route(1): Applying CFDA");
                setbflag(10);

                # Replace the Request-URI with the CFDA target
                $ru = $(avp(cfda));
                # Append a new branch based on the CFDA and route it out.
                append_branch();
                route(1);
                exit;
            }
            # Fallthrough: no alternate found, fail the call.
        }
    }
    else
    {
        xlog("L_DBG","DEBUG -- failure_route[1]: conversation was canceled.");
    }

}

# -----------------------------------------------------------------
# INVITE Message Handler
# -----------------------------------------------------------------

route[3]
{
    xlog("L_DBG","DEBUG -- route(3) $ru -- INVITE Message Handler");

    sl_send_reply("100", "Trying");

    xlog("L_DBG","DEBUG -- route(3): From ip: $si - From URI: $fu");

    if (!allow_trusted())
    {
      sl_sendreply("404","Not found");
      exit;
    }

    # Call is OK to proceed (based on the information of the originator).
    xlog("L_DBG","DEBUG -- route(3): Lookup aliases.");

    # Always trust aliases and proceed as-is with them.
    if(lookup("aliases"))
    {
        route(1);
        return;
    }

    # Invalid destination
    sl_send_reply("404", "User Not Found");
    exit;
}

# -----------------------------------------------------------------
# Loose Route Section
# -----------------------------------------------------------------

route[5]
{
    xlog("L_DBG","DEBUG -- route(5): loose_route $rm From: $fu To: $tu RURI: $ru");

    if((is_method("INVITE") || is_method("REFER")) && !has_totag()) {
        sl_send_reply("403", "Forbidden");
        exit;
    };

    if (is_method("INVITE"))
    {
        # * Authenticate re-INVITE if needed
        if(!allow_trusted())
        {
          sl_sendreply("404","Not found");
          exit;
        }
    }

    if(is_method("ACK") || is_method("CANCEL") || is_method("PRACK"))
    {
        route(8); # Route ACK/PRACK/CANCEL
    }
    else
    {
        route(1);
    }
    return;
}

# --------- EOF inbound-proxy/opensips.cfg -----------
